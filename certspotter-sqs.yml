AWSTemplateFormatVersion: 2010-09-09
Description: SSLMate Cert Spotter monitor of the Certificate Transparency logs, emitting events to SQS
Metadata:
  SourceCode: https://github.com/mozilla/certspotter-cloudformation
  Version: 7.0.0
  Todo1: Convert to AWS lambda function
  Todo2: Add heartbeat/watchdog to detect if the cronjob stops working
Parameters:
  SSHKeyName:
    Description: SSH Key Name
    Type: 'AWS::EC2::KeyPair::KeyName'
  SQSRegion:
    Description: The AWS region containing the target SQS queue
    Type: String
  SQSQueueName:
    Description: The name of the SQS queue to send events to
    Type: String
  SQSAccountId:
    Description: The AWS account ID that contains the SQS queue if that queue is not
      in the local account or the local account's account id if the SQS queue is local
    Type: String
  DynamoDBTableName:
    Description: The name of the DynamoDB table to store matching cert records in
    Type: String
    Default: CertificateTransparencyMatches
  DynamoDBTableRegion:
    Description: The region of the DynamoDB table
    Type: String
  WatchListURI:
    Description: An S3 URL to a JSON document containing the list of domains
      under a 'domains' key
    Type: String
    ConstraintDescription: An S3 URL beginning with s3://
    AllowedPattern: '^s3://.*'
  EIPAllocationId:
    Description: The optional Allocation ID of the already existing Elastic IP you
      want to associate with this new instance
    Type: String
    Default: ''
  StartFromEndOfCTLogs:
    Description: 'Should certspotter start from the current end of the certificate transparency logs? "true" or "false" (Default : true)'
    Type: String
    AllowedValues:
      - true
      - false
    ConstraintDescription: must be either "true" or "false"
    Default: true
  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/canonical/ubuntu/server/jammy/stable/current/amd64/hvm/ebs-gp2/ami-id'

Conditions:
  AssociateEIP: !Not [ !Equals [ !Ref 'EIPAllocationId', '' ] ]
Resources:
  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group
      SecurityGroupIngress:
        - FromPort: 22
          IpProtocol: tcp
          CidrIp: 0.0.0.0/0
          ToPort: 22
  IAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: SendSQSMessage
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:Send*
                  - sqs:GetQueueUrl
                Resource: !Join [ '', [ 'arn:aws:sqs:', !Ref 'SQSRegion', ':', !Ref 'SQSAccountId', ':', !Ref 'SQSQueueName', '*' ] ]
        - PolicyName: StoreRecordInDynamoDB
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:DescribeTable
                  - dynamodb:PutItem
                Resource: !Join [ '', [ 'arn:aws:dynamodb:', !Ref 'DynamoDBTableRegion', ':', !Ref 'AWS::AccountId', ':table/', !Ref 'DynamoDBTableName' ] ]
        - PolicyName: ReadS3Watchlist
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: s3:GetObject
                Resource: !Join [ '', [ 'arn:aws:s3:::', !Select [ '2', !Split [ '/', !Ref 'WatchListURI' ] ], '/*' ] ]
              - Effect: Allow
                Action: s3:ListBucket
                Resource: !Join [ '', [ 'arn:aws:s3:::', !Select [ '2', !Split [ '/', !Ref 'WatchListURI' ] ] ] ]
              - Effect: Allow
                Action: s3:ListAllMyBuckets
                Resource: '*'
  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref IAMRole
  Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: t2.micro
      Tags:
        - Key: Name
          Value: certspotter
      KeyName: !Ref SSHKeyName
      SecurityGroups:
        - !Ref SecurityGroup
      IamInstanceProfile: !Ref InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -ex
          useradd --comment "Certspotter Daemon" --create-home certspotter
          for i in {1..3}; do apt update && apt -y install python3-pip && break || sleep 10; done
          python3 -m pip install --upgrade pip
          PIP_ROOT_USER_ACTION=ignore /bin/pip3 install https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-py3-latest.tar.gz 2>&1 >> /var/log/initial_user-data.log
          cat << 'EOF' > /etc/systemd/system/certspotter.service
          [Unit]
          Description=Certificate Transparency Log Monitor
          Documentation=man:certspotter(8)
          After=network-online.target
          Wants=network-online.target
          
          [Service]
          Type=simple
          User=certspotter
          Group=certspotter
          ExecStart=/home/certspotter/gocode/bin/certspotter -verbose
          # not strict, because we want to allow some flexibility to hooks
          ProtectSystem=full
          
          [Install]
          WantedBy=multi-user.target
          EOF
          wget https://go.dev/dl/go1.21.4.linux-amd64.tar.gz
          rm -rf /usr/local/go && tar -C /usr/local -xzf go1.21.4.linux-amd64.tar.gz
          echo "export PATH=$PATH:/usr/local/go/bin" >> /etc/profile
          apt -y install git jq
          PIP_ROOT_USER_ACTION=ignore /bin/pip3 install awscli boto3
          install --owner=certspotter --group=certspotter --directory /home/certspotter/gocode
          install --owner=certspotter --group=certspotter --directory /home/certspotter/.certspotter
          install --owner=certspotter --group=certspotter --directory /home/certspotter/.certspotter/hooks.d
          install --owner=certspotter --group=certspotter --mode=0644 /dev/null /home/certspotter/.certspotter/watchlist
          /usr/local/bin/aws s3 cp --quiet ${WatchListURI} /dev/stdout | jq -r '.domains|map("."+.)|.[]' > /home/certspotter/.certspotter/watchlist
          runuser --login certspotter -c 'GOPATH=/home/certspotter/gocode /usr/local/go/bin/go install software.sslmate.com/src/certspotter/cmd/certspotter@latest'
          install --owner=certspotter --group=certspotter --mode=0755 /dev/null /home/certspotter/.certspotter/hooks.d/send_to_sqs.py
          install --owner=certspotter --group=certspotter --mode=0644 /dev/null /home/certspotter/certspotter_config.txt
          echo -n "${SQSRegion},${SQSQueueName},${SQSAccountId},${DynamoDBTableName},${DynamoDBTableRegion}" > /home/certspotter/certspotter_config.txt
          cat << 'EOF' > /home/certspotter/.certspotter/hooks.d/send_to_sqs.py
          #!/usr/bin/env python3
          import os, json, datetime, boto3
          base_dir = '/home/certspotter'
          with open(f'{base_dir}/certspotter_config.txt') as f:
              ARGS = [x.strip() for x in f.read().split(',')]

          data = {}
          field_map = {
              'FINGERPRINT': 'ssl_hash',
              'ISSUER_DN': 'ssl_issuer',
              'SERIAL': 'ssl_serial',
              'SUBJECT_DN': 'ssl_subject',
              'NOT_AFTER_UNIXTIME': 'ssl_end_time',
              'NOT_BEFORE_UNIXTIME': 'ssl_start_time',
              'LOG_URI': 'log_uri',
              'PUBKEY_HASH': 'pubkey_hash',
              'CERT_PARSEABLE': 'cert_parseable',
              'ENTRY_INDEX': 'entry_index',
          }
          for key in (set(os.environ.keys()) & field_map.keys()):
              data[field_map[key]] = os.environ[key]
          if 'JSON_FILENAME' not in os.environ:
              with open(f'{base_dir}/certificates_matched.log', 'a') as f:
                  f.write(f"{datetime.datetime.now()} : ERROR encountered, missing JSON_FILENAME : {json.dumps(dict(os.environ))}\n")
              exit(0)
          with open(os.environ['JSON_FILENAME']) as f:
              json_file_data = json.load(f)
          data['dnsnames'] = json_file_data['dns_names']
          with open(f'{base_dir}/.certspotter/watchlist') as f:
              watchlist = f.read().splitlines()

          def in_watchlist(name, watchlist):
              matching_names = [watchname for watchname in watchlist if watchname[:1] == '.' and (name.endswith(watchname) or name == watchname.lstrip('.'))]
              return (name in watchlist) or matching_names

          data['watched_dnsnames'] = [dnsname for dnsname in data['dnsnames'] if in_watchlist(dnsname, watchlist)]
          data['summary'] = f"New certificate{'s' if len(data['watched_dnsnames']) > 1 else ''} in CT logs for {', '.join(data['watched_dnsnames'])}"
          record_id = f"{data['ssl_issuer']}, {data['ssl_serial']}"
          with open(f'{base_dir}/certificates_matched.log', 'a') as f:
              f.write(f"{datetime.datetime.now()} : {data['summary']} with ID \"{record_id}\"\n")
          if ARGS[0] and ARGS[1] and ARGS[2]:
              client = boto3.client('sqs', region_name=ARGS[0])
              queue_url = client.get_queue_url(QueueName=ARGS[1], QueueOwnerAWSAccountId=ARGS[2])['QueueUrl']
              client.send_message(QueueUrl=queue_url, MessageBody=json.dumps(data, sort_keys=True))
          if ARGS[3] and ARGS[4]:
              dynamodb = boto3.resource('dynamodb', region_name=ARGS[4])
              table = dynamodb.Table(ARGS[3])
              table.load()
              table.put_item(Item={
                  'id': record_id,
                  'date': int(data['ssl_start_time']),
                  'record': json.dumps(data, sort_keys=True)})
          EOF
          if [ "${StartFromEndOfCTLogs}" = "true" ]; then
              set +e
              runuser --login certspotter -c 'timeout 30 /home/certspotter/gocode/bin/certspotter -verbose -start_at_end'
              set -e
              echo "Initial certspotter index pointed to the end of current CT logs"
          fi
          systemctl daemon-reload && systemctl enable certspotter.service && systemctl start certspotter.service
          /usr/local/bin/cfn-signal '${WaitConditionHandle}' 2>&1 >> /var/log/initial_user-data.log
  WaitConditionHandle:
    Type: AWS::CloudFormation::WaitConditionHandle
  WaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn: Instance
    Properties:
      Handle: !Ref WaitConditionHandle
      Timeout: '300'
  EIPAssociation:
    Type: AWS::EC2::EIPAssociation
    Condition: AssociateEIP
    Properties:
      AllocationId: !Ref EIPAllocationId
      InstanceId: !Ref Instance
Outputs:
  CloudInitOutput:
    Description: The data returned to the WaitConditionHandle from Cloud Init
    Value: !GetAtt WaitCondition.Data
